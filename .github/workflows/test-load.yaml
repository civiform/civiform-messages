name: Sync New Keys to Translations
# Trigger the workflow on pushes to main that modify the base messages file,
# and allow for manual dispatch.
on:
  workflow_dispatch:
  push:
    branches: [main, annazhang-sync-translations]
jobs:
  sync-messages:
    runs-on: ubuntu-latest

    permissions:
      contents: write # Needed to commit and push changes

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} # Use default token for internal repo actions

      - name: Setup Git User and Environment
        run: |
          git config user.name "civiform-github-automation"
          git config user.email "civiform-dev@exygy.com"
          echo "BRANCH_NAME=sync-i18n/$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV

      - name: Sync Keys to Language Files
        id: sync
        run: |
          # Keep set -e at the top to fail the step on general errors
          set -e
          MESSAGES_FILE="server/conf/i18n/messages"
          
          # Find all language files (messages.fr, messages.am, etc.) but exclude the base messages file.
          # Crucial: Add double quotes around $LANGUAGE_FILES in the for loop to safely handle filenames
          LANGUAGE_FILES=$(find server/conf/i18n -name 'messages.*' -type f | grep -v "${MESSAGES_FILE}$")
          
          if [ -z "$LANGUAGE_FILES" ]; then
            echo "No language files (messages.<lang>) found. Skipping sync."
            echo "changes_made=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Function to extract and clean keys
          extract_keys() {
            # Use LC_ALL=C to prevent grep/awk/sed from crashing on non-standard encoding/characters.
            # 1. Use 'tr -cd ...' to strip control characters (most likely needed fix)
            # 2. Use 'grep -v' to filter comments/empty lines
            # 3. Use 'awk' to get the key
            
            LC_ALL=C cat "$1" | \
            tr -cd '\11\12\15\40-\176\n' | \
            tr -d '\r' | \
            grep -v '^\s*#\|^$' | \
            awk -F'=' '{print $1}' | \
            sed 's/\s*$//'
          }

          BASE_KEYS=$(extract_keys "${MESSAGES_FILE}")
          CHANGES=0

          for LANG_FILE in $LANGUAGE_FILES; do
            echo "Processing ${LANG_FILE}..."
            
            # --- DEBUGGING: Display filename before extraction ---
            if [[ "${LANG_FILE}" == *messages.mh* ]]; then
              echo "--- DEBUG: LANG_FILE is messages.mh. Running extraction."
              # Optionally print the raw file content to check for weird characters
              # cat "${LANG_FILE}" | hexdump -C
            fi
            
            LANG_KEYS=$(extract_keys "${LANG_FILE}")
            
            # --- Temporarily disable set -e before the potentially failing command ---
            set +e
            
            # Find keys in base file that are NOT in language file
            # Note: We are using a temp file approach instead of <(...) as it can sometimes be more stable.
            # However, since you are using process substitution, we will stick to it but be mindful of the failure point.
            NEW_KEYS=$(comm -23 <(echo "$BASE_KEYS" | sort) <(echo "$LANG_KEYS" | sort))
            COMM_EXIT_CODE=$?
            
            # Re-enable set -e if the command was successful
            if [ $COMM_EXIT_CODE -ne 0 ]; then
                echo "ERROR: comm command failed for ${LANG_FILE} with exit code ${COMM_EXIT_CODE}."
                # We do NOT exit here, just report the error and skip this file.
                NEW_KEYS=""
            fi
            set -e

            if [ -z "$NEW_KEYS" ]; then
              echo "No new keys found for ${LANG_FILE}."
            else
              echo "New keys found for ${LANG_FILE}. Appending..."
              
              # Append new keys with an empty value to the language file
              echo "" >> "${LANG_FILE}"
              echo "##################################################" >> "${LANG_FILE}"
              echo "# Keys automatically added from base messages file" >> "${LANG_FILE}"
              echo "##################################################" >> "${LANG_FILE}"
              echo "$NEW_KEYS" | sed 's/$/=/' >> "${LANG_FILE}"
              
              CHANGES=$((CHANGES + 1))
            fi
          done

          # ... rest of the script (unchanged) ...
          if [ $CHANGES -gt 0 ]; then
            echo "Total files updated: ${CHANGES}"
            echo "changes_made=true" >> $GITHUB_OUTPUT
          else
            echo "No changes needed for any language file."
            echo "changes_made=false" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Commit and Push Changes
        if: steps.sync.outputs.changes_made == 'true'
        run: |
          # Create a new branch for the changes
          git checkout -b ${{ env.BRANCH_NAME }}
          
          # Add all changed messages.* files
          git add server/conf/i18n/messages.*
          
          git commit -m "chore(i18n): Sync new keys from messages to messages.<lang> files"
          
          # Push the new branch to the remote
          git push origin ${{ env.BRANCH_NAME }}

      - name: Create Pull Request
        if: steps.sync.outputs.changes_made == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_BODY="This PR was automatically created by the 'Sync New Keys to Translations' workflow to ensure all translation files (e.g., \`messages.fr\`, \`messages.am\`) contain the new keys added to the base \`messages\` file.

          Crucially, only the new keys are added with an empty value (e.g., \`new.key.name=\`). Existing translations are preserved.
          Please review the added empty keys and ensure they are ready for translation."
          
          PR_URL=$(gh pr create \
            --head ${{ env.BRANCH_NAME }} \
            --base main \
            --label "i18n" \
            --title "chore(i18n): Sync new keys to translation files" \
            --body "$PR_BODY")
            
          echo "Created PR at ${PR_URL}"